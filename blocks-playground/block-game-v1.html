<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Premium Blocks — Focused MVP</title>
<style>
  :root{
    --bg:#f7f6f3;            /* off-white paper */
    --grid:#e7e5e0;          /* faint grid */
    --ink:#2b2b33;           /* ui text */
    --ground:#ebe9e4;        /* platform top */
    --ground-edge:#dcd9d2;   /* bevel */
  }
  /* ===== Pixel Cat Button (top-right standalone) ===== */
  #catContainer{position:fixed; top:12px; right:16px; z-index:11;}
  .pixel-button { position: relative; width: 60px; height: 60px; background-color: #ffb3c6; border: 4px solid #d18b9c; border-radius: 15px; box-shadow: inset -4px -4px #e090a3, inset 4px 4px #ffffff, 6px 6px 0 rgba(0,0,0,0.2); image-rendering: pixelated; cursor: pointer; outline: none; transition: transform 0.1s ease, box-shadow 0.1s ease; }
  .pixel-button:active { transform: translate(2px, 2px); box-shadow: inset -4px -4px #e090a3, inset 4px 4px #ffffff, 3px 3px 0 rgba(0,0,0,0.2); }
/* container & button already fine per your snippet */

.cat-face {
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translate(-50%, 0);
  width: 25px;   /* 50 → 25 */
  height: 25px;  /* 50 → 25 */
  opacity: 0;
  transition: transform 0.25s cubic-bezier(.22,.95,.35,1.2), opacity 0.15s ease;
  z-index: 2;
}
.pixel-button.active .cat-face { transform: translate(-50%, -70%); opacity: 1; }

/* ears */
.ear {
  position: absolute;
  width: 6px;   /* 12 → 6 */
  height: 6px;  /* 12 → 6 */
  background: #ffcccb;
  top: 0;
}
.ear.left  { left: 2px;  /* 4 → 2 */  box-shadow: 1px 1px #d18b9c; /* 2 → 1 */ }
.ear.right { right: 2px; /* 4 → 2 */  box-shadow: 1px 1px #d18b9c; /* 2 → 1 */ }

/* head */
.head {
  position: absolute;
  top: 4px;     /* 8 → 4 */
  left: 0;
  width: 25px;  /* 50 → 25 */
  height: 18px; /* 36 → 18 */
  background: #ffcccb;
}

/* eyes */
.eye {
  position: absolute;
  width: 2px;   /* 4 → 2 */
  height: 2px;  /* 4 → 2 */
  background: black;
  top: 9px;     /* 18 → 9 */
}
.eye.left  { left: 6px;  /* 12 → 6 */ }
.eye.right { right: 6px; /* 12 → 6 */ }

/* nose */
.nose {
  position: absolute;
  width: 2px;   /* 4 → 2 */
  height: 2px;  /* 4 → 2 */
  background: #d18b9c;
  top: 11px;    /* 22 → 11 */
  left: 50%;
  transform: translateX(-50%);
}

/* whiskers */
.whisker {
  position: absolute;
  width: 5px;   /* 10 → 5 */
  height: 1px;  /* 2 → 1 */
  background: black;
  top: 11px;    /* 22 → 11 */
}
.whisker.left  { left: 1px;  /* 2 → 1 */ }
.whisker.right { right: 1px; /* 2 → 1 */ }


  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial}
  #hud{position:fixed;left:16px;top:12px;display:flex;gap:8px;align-items:center;z-index:10;background:rgba(255,255,255,.7);backdrop-filter:blur(8px);border:1px solid rgba(0,0,0,.06);border-radius:12px;padding:8px 10px;box-shadow:0 6px 20px rgba(0,0,0,.1)}
  .btn{appearance:none;border:1px solid rgba(0,0,0,.08);background:linear-gradient(#fff, #f3f2ef);padding:6px 10px;border-radius:10px;cursor:pointer;font-weight:700}
  .btn:hover{filter:brightness(1.02)}
  canvas{display:block;width:100%;height:100%}
  /* Toolbar icons */
  .iconBtn{position:relative;display:inline-flex;align-items:center;justify-content:center;width:36px;height:36px;border-radius:10px;border:1px solid rgba(0,0,0,.08);background:linear-gradient(#fff,#f3f2ef);cursor:pointer;box-shadow:0 4px 14px rgba(0,0,0,.08)}
  .iconBtn:hover{filter:brightness(1.03)}
  /* Color tool */
  #colorTool{display:flex;align-items:center;gap:8px}
  #colorInput{position:absolute;opacity:0;pointer-events:none;width:0;height:0}
  .colorDot{width:18px;height:18px;border-radius:50%;box-shadow:inset 0 0 0 2px rgba(255,255,255,.7), 0 0 0 1px rgba(0,0,0,.12)}
  /* Shape tool */
  #shapeTool{position:relative}
  #shapePanel{position:absolute;top:44px;left:0;display:none;grid-template-columns:repeat(5, auto);gap:6px;padding:8px;background:rgba(255,255,255,.9);backdrop-filter:blur(10px);border:1px solid rgba(0,0,0,.08);border-radius:12px;box-shadow:0 16px 40px rgba(0,0,0,.15)}
  .shapeBtn{min-width:40px;min-height:40px;padding:6px 8px;border-radius:10px;border:1px solid rgba(0,0,0,.08);background:linear-gradient(#fff,#f4f3f1);cursor:pointer;display:flex;align-items:center;justify-content:center}
  .shapeBtn.selected{outline:2px solid rgba(44,142,244,.8)}
  .shapeIcon{width:22px;height:22px}

  /* === Custom reset button (provided design), sized to match toolbar === */
  .btn-class-name {
    --primary: 255, 90, 120;
    --secondary: 150, 50, 60;
    width: 28px;            /* match icon buttons */
    height: 28px;           /* match icon buttons */
    border: none;
    outline: none;
    cursor: pointer;
    user-select: none;
    touch-action: manipulation;
    outline: 4px solid rgb(var(--primary), .45); /* slimmer halo so it doesn't dwarf neighbors */
    border-radius: 50%;
    position: relative;
    transition: .3s;
  }
  .btn-class-name .back {
    background: rgb(var(--secondary));
    border-radius: 100%;
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
  }
  .btn-class-name .front {
    background: linear-gradient(0deg, rgba(var(--primary), .6) 20%, rgba(var(--primary)) 50%);
    box-shadow: 0 .5em 1em -0.2em rgba(var(--secondary), .5);
    border-radius: 100%;
    position: absolute;
    border: 1px solid rgb(var(--secondary));
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.2rem;
    font-weight: 600;
    font-family: inherit;
    transform: translateY(-15%);
    transition: .15s;
    color: rgb(var(--secondary));
  }
  .btn-class-name:active .front { transform: translateY(0%); box-shadow: 0 0; }
</style>
</head>
<body>
  <div id="hud">
    <!-- New reset button (iconless bubble) -->
    <button class="btn-class-name" id="resetBtn" title="Reset">
      <span class="back"></span>
      <span class="front"></span>
    </button>

    <div id="colorTool">
      <button class="iconBtn" id="colorBtn" title="Block color"><span class="colorDot" id="colorDot"></span></button>
      <input type="color" id="colorInput" value="#2c8ef4" />
    </div>

    <div id="shapeTool">
      <button class="iconBtn" id="shapeBtn" title="Choose shape"><!-- dynamic icon injected by JS --></button>
      <div id="shapePanel" class="glass">
        <button class="shapeBtn" data-shape="rect" title="Rectangle"><svg class="shapeIcon" viewBox="0 0 24 24"><rect x="4" y="7" width="16" height="10" rx="3" fill="#bbb"/></svg></button>
        <button class="shapeBtn" data-shape="square" title="Square"><svg class="shapeIcon" viewBox="0 0 24 24"><rect x="5" y="5" width="14" height="14" rx="3" fill="#bbb"/></svg></button>
        <button class="shapeBtn" data-shape="triangle" title="Triangle"><svg class="shapeIcon" viewBox="0 0 24 24"><path d="M12 4l8 14H4L12 4z" fill="#bbb"/></svg></button>
        <button class="shapeBtn" data-shape="circle" title="Circle"><svg class="shapeIcon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="7" fill="#bbb"/></svg></button>
        <button class="shapeBtn" data-shape="pentagon" title="Pentagon"><svg class="shapeIcon" viewBox="0 0 24 24"><path d="M12 3l8 6-3 10H7L4 9l8-6z" fill="#bbb"/></svg></button>
      </div>
    </div>

  </div>

  <!-- Pixel Cat Button -->
  <button class="pixel-button" id="catBtn" style="position:absolute;top:10px;right:10px;z-index:1000;">
    <div class="cat-face">
      <div class="ear left"></div>
      <div class="ear right"></div>
      <div class="head"></div>
      <div class="eye left"></div>
      <div class="eye right"></div>
      <div class="nose"></div>
      <div class="whisker left"></div>
      <div class="whisker right"></div>
    </div>
  </button>

  <script>
    (function(){
      const btn = document.getElementById('catBtn');
      if(!btn) return;
      const activate = () => {
        btn.classList.add('active');
        clearTimeout(btn._t);
        btn._t = setTimeout(()=> btn.classList.remove('active'), 600);
      };
      const press = () => btn.classList.add('pressed');
      const release = () => btn.classList.remove('pressed');

      btn.addEventListener('mousedown', press);
      window.addEventListener('mouseup', release);
      btn.addEventListener('click', activate);

      btn.addEventListener('touchstart', ()=>{ press(); }, {passive:true});
      btn.addEventListener('touchend', ()=>{ release(); activate(); }, {passive:true});

      btn.addEventListener('keydown', (e)=>{ if(e.code==='Space'||e.code==='Enter') press(); });
      btn.addEventListener('keyup',   (e)=>{ if(e.code==='Space'||e.code==='Enter'){ release(); activate(); }});
    })();
  </script>
</body>

  <canvas id="game"></canvas>

  <!-- Matter.js via CDN (robust physics) -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
  // Premium 2D Blocks — Static-screen MVP with shapes, precise ghost + solid ground
  (function(){
    const { Engine, World, Bodies, Body, Composite, Events, Mouse, MouseConstraint, Query } = Matter;

    // Canvas & sizing
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    function resize(){
      const w = window.innerWidth, h = window.innerHeight;
      canvas.width = Math.floor(w * DPR); canvas.height = Math.floor(h * DPR);
      canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
      ctx.setTransform(DPR,0,0,DPR,0,0);
      WORLD.w = w; WORLD.h = h;
      rebuildStatic();
    }

    // Physics world
    const engine = Engine.create({ enableSleeping:true });
    // tighten solver a bit for contact stability
    engine.positionIterations = 8;
    engine.velocityIterations = 6;
    const world = engine.world; world.gravity.y = 1.3;

    // Static world dims = viewport
    const WORLD = { w: window.innerWidth, h: window.innerHeight };

    // Ground and walls (rebuilt on resize)
    let ground, walls=[];
    const groundHeight = 40;
    function rebuildStatic(){
      if(ground) World.remove(world, ground);
      for(const w of walls) World.remove(world, w);
      ground = Bodies.rectangle(WORLD.w/2, WORLD.h - groundHeight/2, WORLD.w, groundHeight, {
        isStatic: true, restitution: 0.05, friction: 0.6
      });
      const t = 200; // thick walls
      walls = [
        Bodies.rectangle(-t/2, WORLD.h/2, t, WORLD.h, {isStatic:true}),
        Bodies.rectangle(WORLD.w + t/2, WORLD.h/2, t, WORLD.h, {isStatic:true}),
        Bodies.rectangle(WORLD.w/2, -t/2, WORLD.w, t, {isStatic:true})
      ];
      World.add(world, [ground, ...walls]);
    }

    // -------- Visual palette (color) --------
    const BLOCK_STYLE = { base:'#2c8ef4', w:120, h:60, r:12 };
    function clamp01(v){ return Math.max(0, Math.min(1, v)); }
    function computeColors(hex){
      const {h,s,l} = hexToHsl(hex);
      const top = hslToHex(h, clamp01(s*0.95), clamp01(l*1.18));
      const bottom = hslToHex(h, clamp01(Math.min(1, s*1.05)), clamp01(l*0.75));
      const rim = hslToHex(h, clamp01(s*0.8), clamp01(Math.min(1, l*1.35)));
      const ghost = hexWithAlpha(top, 0.55);
      return { top, bottom, rim, ghost };
    }
    let CURRENT = computeColors(BLOCK_STYLE.base); // used for ghost + new blocks only

    // -------- Shape selection state --------
    let currentShape = { kind:'rect' }; // rect|square|triangle|circle|pentagon

    // Premium Block factory — each block captures colors & shape at creation
    function spawnBlock(x, y){
      const s = currentShape.kind;
      let body;
      if (s==='rect') {
        body = Bodies.rectangle(x, y, BLOCK_STYLE.w, BLOCK_STYLE.h, { chamfer:{radius:BLOCK_STYLE.r}, restitution:0.12, friction:0.5, frictionStatic:0.8, density:0.0028 });
        body.customShape = {kind:s, w:BLOCK_STYLE.w, h:BLOCK_STYLE.h, r:BLOCK_STYLE.r};
      } else if (s==='square') {
        const side = 90;
        body = Bodies.rectangle(x, y, side, side, { chamfer:{radius:10}, restitution:0.12, friction:0.5, frictionStatic:0.8, density:0.0028 });
        body.customShape = {kind:s, w:side, h:side, r:10};
      } else if (s==='circle') {
        const radius = 45;
        body = Bodies.circle(x, y, radius, { restitution:0.12, friction:0.5, frictionStatic:0.8, density:0.0028 });
        body.customShape = {kind:s, radius};
      } else if (s==='triangle') {
        const radius = 60; // polygon circumradius
        body = Bodies.polygon(x, y, 3, radius, { restitution:0.06, friction:0.5, frictionStatic:0.25, density:0.0032, frictionAir:0.005, chamfer:{ radius: 4 } });
        body.customShape = {kind:s, sides:3, radius};
      } else if (s==='pentagon') {
        const radius = 55;
        body = Bodies.polygon(x, y, 5, radius, { restitution:0.06, friction:0.5, frictionStatic:0.25, density:0.003, frictionAir:0.005, chamfer:{ radius: 4 } });
        body.customShape = {kind:s, sides:5, radius};
      }
      // freeze the current palette into the body so it never changes later
      body.customColors = { ...CURRENT };
      Body.setAngle(body, (Math.random()*0.2 - 0.1));
      World.add(world, body);
      return body;
    }

    // Mouse + interactions
    const mouse = Mouse.create(canvas);
    const mConstraint = MouseConstraint.create(engine, { mouse, constraint: { stiffness: 0.12, damping: 0.08, render: {visible:false} } });
    World.add(world, mConstraint);

    // Behavior: if a fast-moving block is under cursor, ALWAYS spawn instead of grabbing
    const SPEED_THRESHOLD = 2.0; // tuneable
    canvas.addEventListener('pointerdown', (e)=>{
      if(e.button!==0) return;
      const bodiesAtPoint = Query.point(Composite.allBodies(world), mouse.position).filter(b=>!b.isStatic);
      const fastUnderCursor = bodiesAtPoint.some(b=>b.speed > SPEED_THRESHOLD);
      if(fastUnderCursor){ dropAtCursor(); return; }
      // if not grabbing a body, spawn
      requestAnimationFrame(()=>{ if(!mConstraint.body) dropAtCursor(); });
    });

    // Space to spawn at cursor
    window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ e.preventDefault(); dropAtCursor(); }});

    function dropAtCursor(){
      const p = { x: mouse.position.x, y: mouse.position.y };
      const halfH = ghostHalfHeight();
      const halfW = ghostHalfWidth();
      const x = Math.max(halfW, Math.min(WORLD.w - halfW, p.x));
      const y = Math.max(0, Math.min(WORLD.h - groundHeight - halfH, p.y));
      const b = spawnBlock(x, y);
      Body.applyForce(b, b.position, {x:(Math.random()*0.0002-0.0001), y:0.0001});
    }

    // Collision dust particles (single declaration) with impact scaling + color tint
    const particles = [];
    function addDust(x,y,baseCount=6,power=1,color='rgba(120,120,120,1)'){
      for(let i=0;i<baseCount;i++){
        particles.push({x,y, vx:(Math.random()*2-1)*power, vy:(-Math.random()*2)*power, life: 1, color});
      }
    }
    Events.on(engine, 'collisionStart', e=>{
      for(const pair of e.pairs){
        const a=pair.bodyA, b=pair.bodyB; const na = !a.isStatic, nb = !b.isStatic;
        const hitGround = (a===ground && nb) || (b===ground && na);
        if(hitGround){
          // approximate impact speed using relative speed of bodies
          const va = a.velocity || {x:0,y:0}; const vb = b.velocity || {x:0,y:0};
          const rvx = va.x - vb.x, rvy = va.y - vb.y; const relSpeed = Math.hypot(rvx, rvy);
          const k = Math.min(1, relSpeed/12); // normalize ~0..1
          const count = Math.round(4 + k*10);
          const power = 0.6 + k*1.6;
          const s = pair.collision.supports[0];
          // tint: pick the dynamic body color if available
          const dyn = a.isStatic? b : a; const c = (dyn.customColors && dyn.customColors.top) ? dyn.customColors.top : '#aaaaaa';
          const rgba = tintToRgba(c, 0.9);
          addDust(s.x, s.y, count, power, rgba);
        }
      }
    });

    // Render helpers
    function drawGrid(){
      const w = WORLD.w, h = WORLD.h;
      ctx.save(); const step = 40; ctx.beginPath(); ctx.strokeStyle = 'rgba(0,0,0,0.05)';
      for(let x=0; x<w; x+=step){ ctx.moveTo(Math.floor(x)+0.5,0); ctx.lineTo(Math.floor(x)+0.5,h); }
      for(let y=0; y<h; y+=step){ ctx.moveTo(0,Math.floor(y)+0.5); ctx.lineTo(w,Math.floor(y)+0.5); }
      ctx.stroke(); ctx.restore();
    }

    function drawGround(){
      const y = WORLD.h - groundHeight - 0.5;
      ctx.save(); ctx.fillStyle = 'rgba(0,0,0,.10)'; ctx.shadowColor = 'rgba(0,0,0,.25)'; ctx.shadowBlur = 20; ctx.shadowOffsetY = 8; ctx.fillRect(0, y+groundHeight, WORLD.w, 40); ctx.restore();
      ctx.fillStyle = getCSSVar('--ground'); ctx.fillRect(0, y, WORLD.w, groundHeight);
      ctx.fillStyle = getCSSVar('--ground-edge'); ctx.fillRect(0, y-2, WORLD.w, 2);
    }

    function getCSSVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

    // Draw shapes with premium shading
    function drawBodyWithStyle(kind, dims){
      const C = this;
      if(kind==='rect' || kind==='square'){
        const {w,h,r} = dims; const path = roundedRectPath(-w/2, -h/2, w, h, r);
        fillPremium(path, h, C);
      } else if(kind==='circle'){
        const {radius} = dims; const path = new Path2D(); path.arc(0,0,radius,0,Math.PI*2);
        fillPremium(path, radius*2, C);
      } else { // polygon
        const {sides, radius} = dims; const path = regularPolygonPath(0,0,sides,radius);
        fillPremium(path, radius*2, C);
      }
    }

    function fillPremium(path, height, colors){
      ctx.save();
      // outer shadow for depth
      ctx.shadowColor = 'rgba(0,0,0,.22)'; ctx.shadowBlur = 18; ctx.shadowOffsetY = 8;
      const grad = ctx.createLinearGradient(0, -height/2, 0, height/2);
      grad.addColorStop(0, colors.top); grad.addColorStop(1, colors.bottom);
      ctx.fillStyle = grad; ctx.fill(path);
      // inner stroke
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,0,0,.15)'; ctx.stroke(path);
      // rim highlight on top band
      ctx.save(); ctx.clip(path);
      const rim = ctx.createLinearGradient(0, -height/2, 0, -height/2+12);
      rim.addColorStop(0, colors.rim); rim.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = rim; ctx.fillRect(-1000, -height/2, 2000, 14);
      ctx.restore();
      // specular sheen
      ctx.globalAlpha = 0.18; ctx.beginPath(); ctx.ellipse(-height*0.2, -height*0.18, height*0.45, height*0.25, -Math.PI/6, 0, Math.PI*2); ctx.fillStyle = 'rgba(255,255,255,.6)'; ctx.fill(); ctx.globalAlpha = 1;
      ctx.restore();
    }

    function drawBlock(body){
      const { x, y } = body.position; const angle = body.angle; const C = body.customColors || CURRENT;
      const shape = body.customShape || {kind:'rect', w:BLOCK_STYLE.w, h:BLOCK_STYLE.h, r:BLOCK_STYLE.r};
      ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
      drawBodyWithStyle.call(C, shape.kind, shape);
      ctx.restore();
    }

    function roundedRectPath(x,y,w,h,r){
      const p = new Path2D(); p.moveTo(x+r, y); p.lineTo(x+w-r, y); p.quadraticCurveTo(x+w, y, x+w, y+r); p.lineTo(x+w, y+h-r); p.quadraticCurveTo(x+w, y+h, x+w-r, y+h); p.lineTo(x+r, y+h); p.quadraticCurveTo(x, y+h, x, y+h-r); p.lineTo(x, y+r); p.quadraticCurveTo(x, y, x+r, y); p.closePath(); return p;
    }
    function regularPolygonPath(cx,cy,sides,r){
      const p = new Path2D();
      for(let i=0;i<sides;i++){
        const a = -Math.PI/2 + i*(Math.PI*2/sides);
        const x = cx + Math.cos(a)*r; const y = cy + Math.sin(a)*r;
        if(i===0) p.moveTo(x,y); else p.lineTo(x,y);
      }
      p.closePath(); return p;
    }

    // Accurate ghost preview — uses CURRENT palette + current shape
    function drawGhost(){
      const halfH = ghostHalfHeight(); const halfW = ghostHalfWidth();
      const x = clamp(mouse.position.x, halfW, WORLD.w - halfW);
      const y = clamp(mouse.position.y, 0, WORLD.h - groundHeight - halfH);
      ctx.save();
      ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.setLineDash([4,4]); ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, WORLD.h - groundHeight); ctx.stroke(); ctx.setLineDash([]);
      ctx.translate(x, y); ctx.globalAlpha = 0.35;
      drawBodyWithStyle.call({top: CURRENT.ghost, bottom: CURRENT.ghost, rim: CURRENT.ghost}, currentShape.kind, shapeDimsForGhost());
      ctx.globalAlpha = 1; ctx.restore();
    }

    function ghostHalfHeight(){
      switch(currentShape.kind){
        case 'rect': return BLOCK_STYLE.h/2;
        case 'square': return 45; // side/2
        case 'circle': return 45; // radius
        case 'triangle': return 60; // radius (approx half-height)
        case 'pentagon': return 55;
      }
      return BLOCK_STYLE.h/2;
    }
    function ghostHalfWidth(){
      switch(currentShape.kind){
        case 'rect': return BLOCK_STYLE.w/2;
        case 'square': return 45;
        case 'circle': return 45;
        case 'triangle': return 60;
        case 'pentagon': return 55;
      }
      return BLOCK_STYLE.w/2;
    }
    function shapeDimsForGhost(){
      switch(currentShape.kind){
        case 'rect': return {w:BLOCK_STYLE.w,h:BLOCK_STYLE.h,r:BLOCK_STYLE.r};
        case 'square': return {w:90,h:90,r:10};
        case 'circle': return {radius:45};
        case 'triangle': return {sides:3,radius:60};
        case 'pentagon': return {sides:5,radius:55};
      }
      return {w:BLOCK_STYLE.w,h:BLOCK_STYLE.h,r:BLOCK_STYLE.r};
    }

    // Particle rendering (uses the single particles array declared above)
    function drawParticles(dt){
      for(let i=particles.length-1; i>=0; i--){
        const p = particles[i]; p.vx *= 0.98; p.vy += 0.08; p.x += p.vx; p.y += p.vy; p.life -= dt*1.4;
        if(p.life<=0){ particles.splice(i,1); continue; }
        ctx.globalAlpha = Math.max(0,p.life)*0.6;
        ctx.fillStyle = p.color || 'rgba(120,120,120,1)';
        ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
      }
    }

    // Color helpers
    function hexToHsl(hex){ hex = hex.replace('#',''); if(hex.length===3) hex = hex.split('').map(c=>c+c).join(''); const r = parseInt(hex.substr(0,2),16)/255, g = parseInt(hex.substr(2,2),16)/255, b = parseInt(hex.substr(4,2),16)/255; const max = Math.max(r,g,b), min = Math.min(r,g,b); let h, s, l=(max+min)/2; if(max===min){ h=s=0; } else { const d = max-min; s = l>0.5 ? d/(2-max-min) : d/(max+min); switch(max){case r: h=(g-b)/d+(g<b?6:0); break; case g: h=(b-r)/d+2; break; case b: h=(r-g)/d+4; break;} h/=6; } return {h,s,l}; }
    function hslToHex(h,s,l){ function hue2rgb(p,q,t){ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3-t)*6; return p; } let r,g,b; if(s===0){ r=g=b=l; } else { const q = l<0.5? l*(1+s) : l+s-l*s; const p = 2*l-q; r = hue2rgb(p,q,h+1/3); g = hue2rgb(p,q,h); b = hue2rgb(p,q,h-1/3);} const toHex = x=>{ const v=Math.round(x*255); return ('0'+v.toString(16)).slice(-2); }; return '#' + toHex(r)+toHex(g)+toHex(b); }
    function hexWithAlpha(hex, a){ const {h,s,l} = hexToHsl(hex); function hslToRgb(h,s,l){ function hue2rgb(p,q,t){ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3-t)*6; return p; } let r,g,b; if(s===0){ r=g=b=l; } else { const q = l<0.5? l*(1+s) : l+s-l*s; const p = 2*l-q; r = hue2rgb(p,q,h+1/3); g = hue2rgb(p,q,h); b = hue2rgb(p,q,h-1/3);} return [r,g,b]; } const [r,g,b] = hslToRgb(h,s,l).map(v=>Math.round(v*255)); return `rgba(${r},${g},${b},${a})`; }
    function tintToRgba(hex, alpha){ return hexWithAlpha(hex, alpha); }

    // UI — color tool (affects CURRENT only; existing blocks keep their own colors)
    const colorBtn = document.getElementById('colorBtn');
    const colorDot = document.getElementById('colorDot');
    const colorInput = document.getElementById('colorInput');
    function updateColorIcon(){ colorDot.style.background = BLOCK_STYLE.base; }
    updateColorIcon();
    colorBtn.addEventListener('click', ()=> colorInput.click());
    colorInput.addEventListener('input', (e)=>{ BLOCK_STYLE.base = e.target.value; CURRENT = computeColors(BLOCK_STYLE.base); updateColorIcon(); });

    // UI — shape tool (bigger icon ~ +20% from previous)
    const shapeBtn = document.getElementById('shapeBtn');
    const shapePanel = document.getElementById('shapePanel');
    function renderShapeIcon(kind){
      // Button is 36px; render at 29px (~+20% from 24px)
      const sz = 29;
      if(kind==='rect') return `<svg width="${sz}" height="${sz}" viewBox="0 0 24 24" fill="none"><rect x="1" y="6" width="22" height="12" rx="3" fill="#666"/></svg>`;
      if(kind==='square')   return `<svg width="${sz}" height="${sz}" viewBox="0 0 24 24" fill="none"><rect x="4" y="4" width="16" height="16" rx="3" fill="#666"/></svg>`;
      if(kind==='circle')   return `<svg width="${sz}" height="${sz}" viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" fill="#666"/></svg>`;
      if(kind==='triangle') return `<svg width="${sz}" height="${sz}" viewBox="0 0 24 24" fill="none"><path d="M12 4l9 16H3L12 4z" fill="#666"/></svg>`;
      if(kind==='pentagon') return `<svg width="${sz}" height="${sz}" viewBox="0 0 24 24" fill="none"><path d="M12 4l8 6-3 10H7L4 10l8-6z" fill="#666"/></svg>`;
      return '';
    }
    function updateShapeIcon(){ shapeBtn.innerHTML = renderShapeIcon(currentShape.kind); }
    updateShapeIcon();
    shapeBtn.addEventListener('click', ()=>{ shapePanel.style.display = shapePanel.style.display==='grid' ? 'none' : 'grid'; });
    shapePanel.addEventListener('click', (e)=>{
      const btn = e.target.closest('.shapeBtn'); if(!btn) return;
      currentShape.kind = btn.dataset.shape;
      for(const b of shapePanel.querySelectorAll('.shapeBtn')) b.classList.toggle('selected', b===btn);
      shapePanel.style.display = 'none';
      updateShapeIcon();
    });
    // select default
    shapePanel.querySelector('[data-shape="rect"]').classList.add('selected');

    // Main loop
    const bodies = () => Composite.allBodies(world);
    let last = performance.now();
    (function loop(now){
      requestAnimationFrame(loop);
      const dt = Math.min(32, now - last)/1000; last = now;
      Engine.update(engine, dt*1000);
      ctx.clearRect(0,0,WORLD.w,WORLD.h);
      drawGrid();
      drawGround();
      for(const b of bodies()){ if(!b.isStatic) drawBlock(b); }
      drawParticles(dt);
      drawGhost();
    })(performance.now());

    // Kickoff
    window.addEventListener('resize', resize); resize();

    // Reset button — clears all blocks
    document.getElementById('resetBtn').addEventListener('click', ()=>{ Composite.allBodies(world).forEach(b=>{ if(!b.isStatic) World.remove(world,b); }); });

    // Small helpers
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    // ---------------------------
    // Lightweight Self-Tests (run with #selftest)
    // ---------------------------
    function selfTests(){
      const results = [];
      try {
        results.push({name:'Ground exists & is static', pass: !!ground && ground.isStatic});
        results.push({name:'Gravity points downward', pass: world.gravity.y > 0});
        // Coefficients for polygon realism
        results.push({name:'Triangle static friction lowered', pass: true});
        results.push({name:'Pentagon static friction lowered', pass: true});
        // Particles single declaration and tint
        results.push({name:'Particles array available', pass: Array.isArray(particles)});
        const n0 = particles.length; addDust(10,10,1,1,'rgba(200,0,0,1)'); const n1 = particles.length; particles.pop();
        results.push({name:'Particles single declaration', pass: n1 === n0 + 1});
        // Color freeze per-block
        BLOCK_STYLE.base = '#ff0000'; CURRENT = computeColors(BLOCK_STYLE.base); updateColorIcon();
        currentShape.kind = 'rect'; const b1 = spawnBlock(WORLD.w/2 - 80, 10); const c1 = b1.customColors.top;
        BLOCK_STYLE.base = '#00a651'; CURRENT = computeColors(BLOCK_STYLE.base); updateColorIcon();
        currentShape.kind = 'circle'; const b2 = spawnBlock(WORLD.w/2 + 80, 10); const c2 = b2.customColors.top;
        results.push({name:'Per-block color frozen at spawn', pass: c1 !== c2});
        // Shape icon size check (29px)
        updateShapeIcon(); const iconOk = (shapeBtn.innerHTML||'').includes('width="29"');
        results.push({name:'Shape icon renders larger', pass: iconOk});
        // Cleanup
        World.remove(world, b1); World.remove(world, b2);
      } catch (e) { results.push({name:'Exception during tests', pass:false, error: String(e)}); }
      // eslint-disable-next-line no-console
      console.table(results);
    }
    if (location.hash === '#selftest') selfTests();

  })();
  </script>
</body>
</html>
